<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Maíra Canal | Rust for VGEM</title>
    <meta name="description" content="Blogging about graphics development whenever I can"
    />
    

    <link rel="canonical" href="https://mairacanal.github.io/rust-for-vgem/" />
    <!-- Common head elements I use in this website and cgit -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="icon" href="data:,">

<link rel="stylesheet" href="/assets/style.css" />
<link rel="stylesheet" href="https://colors.m7.rs/catppuccin-latte.css" />
<link rel="stylesheet" href="https://colors.m7.rs/catppuccin-frappe.css" media="(prefers-color-scheme: dark)" />
<link rel="stylesheet" href="https://colors.m7.rs/.css" media="print" />
<link rel="stylesheet" id="theme-css" />

<script src="/assets/main.js"></script>

  </head>
  <body>
    <header>
  <div class="title">{ <a href="/">Maíra Canal</a> }</div>
<nav>
    <ul>
      
      <li>
        <a class="colorscheme" aria-label="Change colorscheme" href="/colorscheme/">
          
        </a>
      </li>
      
      <li>
        <a href="/about-me/">
          
            about
          
        </a>
      </li>
      
      <li>
        <a href="/">
          
            blog
          
        </a>
      </li>
      
      <li>
        <a href="/cv/">
          
            cv
          
        </a>
      </li>
      
    </ul>
</nav>

</header>

<main>
  <article>
    <header>
      <h1>Rust for VGEM</h1>
      
      
        <p>
          Date: <time datetime="2023-02-28T00:00:00+00:00">28th February 2023</time>
        </p>
      
      
        <p>
          Tags:
          
            <a href="/notes#igalia">#igalia</a>
          
            <a href="/notes#graphics">#graphics</a>
          
        </p>
      
    </header>

    <p>In the last blog post, I pointed out that I didn’t know exactly what it would be
my next steps for the near future. Gladly, I had the amazing opportunity to
start a new <a href="https://www.igalia.com/coding-experience/" class="external">Igalia Coding
Experience</a> with a new project.</p>

<p>This time <a href="https://melissawen.github.io/" class="external">Melissa Wen</a> pitched me with the idea
to play around with Rust for Linux in order to rewrite the VGEM driver in Rust.
The Rust for Linux project is growing fast with new bindings and abstractions
being introduced in the downstream RfL kernel. Also, some basic functionalities
were introduced in Linux 6.1. Therefore, it seems like a great timing to start
exploring Rust in the DRM subsystem!</p>

<h1 id="why-rust">Why Rust?</h1>
<hr>
<p>As mentioned by the Rust website, using Rust means <strong>Performance</strong>,
<strong>Reliability</strong>, and <strong>Productivity</strong>. Rust is a blazingly fast and
memory-efficient language with its powerful <strong>ownership model</strong>. No more looking
for use-after-free and memory leaks, as Rust guarantees memory safety and thread
safety, eliminating a handful of bugs at compile-time.</p>

<p>Moreover, Rust provides a new way of programming. The language provides
beautiful features such as traits, enums, and error handling, that can
make us feel empowered by the language. We can use a lot of concepts from
functional programming and mix them with concepts from OOP, for example.</p>

<p>Although I’m an absolute beginner in Rust, I can see the major advantages of the
Rust programming language. From the start, it was a bit tough to enjoy the
language, as I was fighting with the compiler most of the time. But now that I
have a more firm foundation on Rust, it is possible to appreciate the beauty in
Rust and I don’t see myself starting a new project in C++ for a long while.</p>

<p>Bringing Rust to the Linux Kernel is a ambitious idea, but it can lead to
great changes. We can think about a world where no developers are looking for
memory leaks and use-after-free bugs due to the safety that Rust can provide us.</p>

<h1 id="rust-on-drm">Rust on DRM</h1>
<hr>
<p>Now, what about Rust for DRM? I mean, I’m not the first one to think about it.
<a href="https://twitter.com/LinaAsahi" class="external">Asahi Lina</a> is making a fantastic work on the
Apple M1 GPU and things are moving quite fast there. She already had great safe
abstractions for the DRM bindings and provides us the very basis for anyone who
is willing to start a new DRM driver in Rust, which is my case.</p>

<p>That said, why not make use of Lina’s excellent bindings to build a new driver?</p>

<h1 id="rust-for-vgem">Rust for VGEM</h1>
<hr>
<p>VGEM (Virtual GEM Provider) is a minimal non-hardware backed GEM (Graphics
Execution Manager) service. It is used with non-native 3D hardware for buffer
sharing between the X server and DRI. It is a fairly simple driver with about
400 lines of code and it uses the DMA Fence API to handle attaching and
signaling the fences.</p>

<p>So, to rewrite VGEM in Rust, some bindings are needed, e.g. bindings for
platform device, for XArray, and for dealing with DMA fence and DMA
reservations. Furthermore, many DRM abstractions are needed as well.</p>

<p>In this sense, a lot of the DRM abstractions are already developed by Lina and
also she is developing abstractions for DMA fence. So, in this project, I’ll be
focusing on the bindings that Lina and the RfL folks haven’t developed yet.</p>

<p>After developing the bindings, it is a matter of developing the driver, which
it’ll be quite simple after all DMA abstractions are set, because most of the
driver consists of fence manipulation.</p>

<h1 id="current-status">Current Status</h1>
<hr>
<p>I have developed the main platform device registration of the driver. As VGEM is
a virtual device, the standard probe initialization is not useful, as a virtual
device cannot be probed by the pseudo-bus that holds the platform devices. So,
as VGEM is not a usual hotplugged device, we need to use the legacy platform
device initialization. This made me develop my first binding for legacy
registration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Add a platform-level device and its resources
pub fn register(name: &amp;'static CStr, id: i32) -&gt; Result&lt;Self&gt; {
	let pdev = from_kernel_err_ptr(unsafe {
		bindings::platform_device_register_simple(name.as_char_ptr(), id,
			core::ptr::null(), 0)
	})?;

	Ok(Self {
		ptr: pdev,
		used_resource: 0,
		is_registered: true,
	})
}
</code></pre></div></div>

<p>For sure, the registration must follow the unregistration of the device, so I
implemented a Drop trait for the struct Device in order to guarantee the proper
device removal without explicitly calling it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>impl Drop for Device {
	fn drop(&amp;mut self) {
		if self.is_registered {
			// SAFETY: This path only runs if a previous call to `register`
			// completed successfully.
			unsafe { bindings::platform_device_unregister(self.ptr) };
		}
	}
}
</code></pre></div></div>

<p>After those, I also developed bindings for a couple of more functions and
together with Lina’s bindings, I could initialize the platform device and
register the DRM device under a DRM minor!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[   38.825684] vgem: vgem_init: platform_device with id -1
[   38.826505] [drm] Initialized vgem 1.0.0 20230201 for vgem on minor 0
[   38.858230] vgem: Opening...
[   38.862377] vgem: Closing...
[   41.543416] vgem: vgem_exit: drop
</code></pre></div></div>

<p>Next, I focused on the development of the two IOCTLs: <code class="language-plaintext highlighter-rouge">drm_vgem_fence_attach</code>
and <code class="language-plaintext highlighter-rouge">drm_vgem_fence_signal</code>. The first is responsable for creating and attaching
a fence to the VGEM handle, while the second signals and consumes a fence
earlier attached to a VGEM handle.</p>

<p>In order to add a fence, bindings to DMA reservation are needed. So, I started
by creating a safe abstraction for <code class="language-plaintext highlighter-rouge">struct dma_resv</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// A generic DMA Resv Object
///
/// # Invariants
/// ptr is a valid pointer to a dma_resv and we own a reference to it.
pub struct DmaResv {
    ptr: *mut bindings::dma_resv,
}

impl DmaResv {
	
    [...]
	
    /// Add a fence to the dma_resv object
    pub fn add_fences(
        &amp;self,
        fence: &amp;dyn RawDmaFence,
        num_fences: u32,
        usage: bindings::dma_resv_usage,
    ) -&gt; Result {
        unsafe { bindings::dma_resv_lock(self.ptr, core::ptr::null_mut()) };

        let ret = self.reserve_fences(num_fences);
        match ret {
            Ok(_) =&gt; {
                // SAFETY: ptr is locked with dma_resv_lock(), and dma_resv_reserve_fences()
                // has been called.
                unsafe {
                    bindings::dma_resv_add_fence(self.ptr, fence.raw(), usage);
                }
            }
            Err(_) =&gt; {}
        }
        
        unsafe { bindings::dma_resv_unlock(self.ptr) };

        ret
    }
}
</code></pre></div></div>

<p>With that step, I could simply write the IOCTLs based on the new <code class="language-plaintext highlighter-rouge">DmaResv</code>
abstraction and Lina’s fence abstractions.</p>

<p>To test the IOCTLs, I used some already available IGT tests: <code class="language-plaintext highlighter-rouge">dmabuf_sync_file</code>
and <code class="language-plaintext highlighter-rouge">vgem_basic</code>. Those tests use VGEM as it base, so if the tests pass, it
means that the IOCTLs are working properly. And, after some debugging and rework
in the IOCTLs, I managed to get most of the tests to pass!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[root@fedora igt-gpu-tools]# ./build/tests/dmabuf_sync_file
IGT-Version: 1.27-gaa16e812 (x86_64) (Linux: 6.2.0-rc3-asahi-02441-g6c8eda039cfb-dirty x86_64)
Starting subtest: export-basic
Subtest export-basic: SUCCESS (0.000s)
Starting subtest: export-before-signal
Subtest export-before-signal: SUCCESS (0.000s)
Starting subtest: export-multiwait
Subtest export-multiwait: SUCCESS (0.000s)
Starting subtest: export-wait-after-attach
Subtest export-wait-after-attach: SUCCESS (0.000s)
</code></pre></div></div>

<p>You can check out the current progress of this project on this
<a href="https://github.com/mairacanal/linux/pull/11" class="external">pull request</a>.</p>

<h1 id="next-steps">Next Steps</h1>
<hr>
<p>Although most of the IGT tests are now passing, two tests aren’t working yet:
<code class="language-plaintext highlighter-rouge">vgem_slow</code>, as I haven’t introduced the timeout yet, and <code class="language-plaintext highlighter-rouge">vgem_basic@unload</code>,
as I still need to debug why the <code class="language-plaintext highlighter-rouge">Drop</code> trait from <code class="language-plaintext highlighter-rouge">drm::drv::Registration</code> is
not being called.</p>

<p>After bypassing those two problems, I still need to rework some of my code, as,
for example, I’m using a dummy IOCTL as IOCTL number 0x00, as the current macro
<code class="language-plaintext highlighter-rouge">kernel::declare_drm_ioctl</code> doesn’t support any drivers for which the IOCTL doesn’t
start in 0x00.</p>

<p>So, there is a lot of work yet to be done!</p>


  </article>
</main>

<footer>
  <address>
  <p>
      E-mail:
      <a href="mailto:mairacanal@riseup.net">mairacanal@riseup.net</a>;
    <br>
    <span class="pgp">PGP:
      <a href="/pgp.asc">
        <span>D902 5017 00AF C8B3 A4F6 7C20</span> B02E E8FD 7678 1ED5
      </a>
    </span>
  </p>

  <p>
    Social:
    <a href="https://github.com/mairacanal" class="external">GitHub</a>;
    <a href="https://gitlab.freedesktop.org/mairacanal" class="external">GitLab</a>;
    <a href="https://linkedin.com/in/mairacanal" class="external">LinkedIn</a>;
    <a href="https://matrix.to/#/@mairacanal:matrix.org" class="external">Matrix</a>;
  </p>

  <p class="copyleft">Copyleft <a href="https://m7.rs/" class="external">Gabriel Fontes</a> (<a href="https://github.com/Misterio77/website" class="external">Source Code</a>)</p>
</address>

<p class="print-site-link"><small>Also available at <a href="https://mairacanal.github.io/rust-for-vgem/" class="external">my website</a>.</small></p>

</footer>

  </body>
</html>
