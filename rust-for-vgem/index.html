<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Maíra Canal | Rust for VGEM</title>
    <meta name="description" content="Blogging about graphics development whenever I can"
    />
    

    <link rel="canonical" href="https://mairacanal.github.io/rust-for-vgem/" />
    <!-- Common head elements I use in this website and cgit -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="icon" href="data:,">

<link rel="stylesheet" href="/assets/style.css" />
<link rel="stylesheet" href="https://m7.rs/colors/catppuccin-frappe.css" />
<link rel="stylesheet" href="https://m7.rs/colors/catppuccin-frappe.css" media="(prefers-color-scheme: dark)" />
<link rel="stylesheet" href="https://m7.rs/colors/.css" media="print" />
<link rel="stylesheet" id="theme-css" />

<script src="/assets/main.js"></script>

  </head>
  <body>
    <header>
  <div class="title">{ <a href="/">Maíra Canal</a> }</div>
<nav>
    <ul>
      
      <li>
        <a class="colorscheme" aria-label="Change colorscheme" href="/colorscheme/">
          
        </a>
      </li>
      
      <li>
        <a href="/about-me/">
          
            about
          
        </a>
      </li>
      
      <li>
        <a href="/">
          
            blog
          
        </a>
      </li>
      
      <li>
        <a href="/life/">
          
            life
          
        </a>
      </li>
      
      <li>
        <a href="/cv/">
          
            cv
          
        </a>
      </li>
      
    </ul>
</nav>

</header>

<main>
  <article>
    <header>
      <h1>Rust for VGEM</h1>
      
      
        <p>
          Date: <time datetime="2023-02-28T00:00:00+00:00">28th February 2023</time>
        </p>
      
      
        <p>
          Tags:
          
            <a href="/notes#igalia">#igalia</a>
          
            <a href="/notes#graphics">#graphics</a>
          
        </p>
      
    </header>

    <p>In the last blog post, I pointed out that I didn’t know exactly what it would be
my next steps for the near future. Gladly, I had the amazing opportunity to
start a new <a href="https://www.igalia.com/coding-experience/" target="_blank" rel="noopener noreferrer" class="external">Igalia Coding
Experience</a> with a new project.</p>

<p>This time <a href="https://melissawen.github.io/" target="_blank" rel="noopener noreferrer" class="external">Melissa Wen</a> pitched me with the idea
to play around with Rust for Linux in order to rewrite the VGEM driver in Rust.
The Rust for Linux project is growing fast with new bindings and abstractions
being introduced in the downstream RfL kernel. Also, some basic functionalities
were introduced in Linux 6.1. Therefore, it seems like a great timing to start
exploring Rust in the DRM subsystem!</p>

<h1 id="why-rust">Why Rust?</h1>
<hr>
<p>As mentioned by the Rust website, using Rust means <strong>Performance</strong>,
<strong>Reliability</strong>, and <strong>Productivity</strong>. Rust is a blazingly fast and
memory-efficient language with its powerful <strong>ownership model</strong>. No more looking
for use-after-free and memory leaks, as Rust guarantees memory safety and thread
safety, eliminating a handful of bugs at compile-time.</p>

<p>Moreover, Rust provides a new way of programming. The language provides
beautiful features such as traits, enums, and error handling, that can
make us feel empowered by the language. We can use a lot of concepts from
functional programming and mix them with concepts from OOP, for example.</p>

<p>Although I’m an absolute beginner in Rust, I can see the major advantages of the
Rust programming language. From the start, it was a bit tough to enjoy the
language, as I was fighting with the compiler most of the time. But now that I
have a more firm foundation on Rust, it is possible to appreciate the beauty in
Rust and I don’t see myself starting a new project in C++ for a long while.</p>

<p>Bringing Rust to the Linux Kernel is a ambitious idea, but it can lead to
great changes. We can think about a world where no developers are looking for
memory leaks and use-after-free bugs due to the safety that Rust can provide us.</p>

<h1 id="rust-on-drm">Rust on DRM</h1>
<hr>
<p>Now, what about Rust for DRM? I mean, I’m not the first one to think about it.
<a href="https://twitter.com/LinaAsahi" target="_blank" rel="noopener noreferrer" class="external">Asahi Lina</a> is making a fantastic work on the
Apple M1 GPU and things are moving quite fast there. She already had great safe
abstractions for the DRM bindings and provides us the very basis for anyone who
is willing to start a new DRM driver in Rust, which is my case.</p>

<p>That said, why not make use of Lina’s excellent bindings to build a new driver?</p>

<h1 id="rust-for-vgem">Rust for VGEM</h1>
<hr>
<p>VGEM (Virtual GEM Provider) is a minimal non-hardware backed GEM (Graphics
Execution Manager) service. It is used with non-native 3D hardware for buffer
sharing between the X server and DRI. It is a fairly simple driver with about
400 lines of code and it uses the DMA Fence API to handle attaching and
signaling the fences.</p>

<p>So, to rewrite VGEM in Rust, some bindings are needed, e.g. bindings for
platform device, for XArray, and for dealing with DMA fence and DMA
reservations. Furthermore, many DRM abstractions are needed as well.</p>

<p>In this sense, a lot of the DRM abstractions are already developed by Lina and
also she is developing abstractions for DMA fence. So, in this project, I’ll be
focusing on the bindings that Lina and the RfL folks haven’t developed yet.</p>

<p>After developing the bindings, it is a matter of developing the driver, which
it’ll be quite simple after all DMA abstractions are set, because most of the
driver consists of fence manipulation.</p>

<h1 id="current-status">Current Status</h1>
<hr>
<p>I have developed the main platform device registration of the driver. As VGEM is
a virtual device, the standard probe initialization is not useful, as a virtual
device cannot be probed by the pseudo-bus that holds the platform devices. So,
as VGEM is not a usual hotplugged device, we need to use the legacy platform
device initialization. This made me develop my first binding for legacy
registration:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Add a platform-level device and its resources</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">register</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="n">CStr</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">pdev</span> <span class="o">=</span> <span class="nf">from_kernel_err_ptr</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span>
		<span class="nn">bindings</span><span class="p">::</span><span class="nf">platform_device_register_simple</span><span class="p">(</span><span class="n">name</span><span class="nf">.as_char_ptr</span><span class="p">(),</span> <span class="n">id</span><span class="p">,</span>
			<span class="nn">core</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">})</span><span class="o">?</span><span class="p">;</span>

	<span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
		<span class="n">ptr</span><span class="p">:</span> <span class="n">pdev</span><span class="p">,</span>
		<span class="n">used_resource</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">is_registered</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For sure, the registration must follow the unregistration of the device, so I
implemented a Drop trait for the struct Device in order to guarantee the proper
device removal without explicitly calling it.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Device</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="k">self</span><span class="py">.is_registered</span> <span class="p">{</span>
			<span class="c1">// SAFETY: This path only runs if a previous call to `register`</span>
			<span class="c1">// completed successfully.</span>
			<span class="k">unsafe</span> <span class="p">{</span> <span class="nn">bindings</span><span class="p">::</span><span class="nf">platform_device_unregister</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">};</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After those, I also developed bindings for a couple of more functions and
together with Lina’s bindings, I could initialize the platform device and
register the DRM device under a DRM minor!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[   38.825684] vgem: vgem_init: platform_device with id -1
[   38.826505] [drm] Initialized vgem 1.0.0 20230201 for vgem on minor 0
[   38.858230] vgem: Opening...
[   38.862377] vgem: Closing...
[   41.543416] vgem: vgem_exit: drop
</code></pre></div></div>

<p>Next, I focused on the development of the two IOCTLs: <code class="language-plaintext highlighter-rouge">drm_vgem_fence_attach</code>
and <code class="language-plaintext highlighter-rouge">drm_vgem_fence_signal</code>. The first is responsable for creating and attaching
a fence to the VGEM handle, while the second signals and consumes a fence
earlier attached to a VGEM handle.</p>

<p>In order to add a fence, bindings to DMA reservation are needed. So, I started
by creating a safe abstraction for <code class="language-plaintext highlighter-rouge">struct dma_resv</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// A generic DMA Resv Object</span>
<span class="cd">///</span>
<span class="cd">/// # Invariants</span>
<span class="cd">/// ptr is a valid pointer to a dma_resv and we own a reference to it.</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DmaResv</span> <span class="p">{</span>
    <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nn">bindings</span><span class="p">::</span><span class="n">dma_resv</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DmaResv</span> <span class="p">{</span>
	
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>
	
    <span class="cd">/// Add a fence to the dma_resv object</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_fences</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">fence</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">RawDmaFence</span><span class="p">,</span>
        <span class="n">num_fences</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
        <span class="n">usage</span><span class="p">:</span> <span class="nn">bindings</span><span class="p">::</span><span class="n">dma_resv_usage</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">bindings</span><span class="p">::</span><span class="nf">dma_resv_lock</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">,</span> <span class="nn">core</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">())</span> <span class="p">};</span>

        <span class="k">let</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.reserve_fences</span><span class="p">(</span><span class="n">num_fences</span><span class="p">);</span>
        <span class="k">match</span> <span class="n">ret</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// SAFETY: ptr is locked with dma_resv_lock(), and dma_resv_reserve_fences()</span>
                <span class="c1">// has been called.</span>
                <span class="k">unsafe</span> <span class="p">{</span>
                    <span class="nn">bindings</span><span class="p">::</span><span class="nf">dma_resv_add_fence</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">,</span> <span class="n">fence</span><span class="nf">.raw</span><span class="p">(),</span> <span class="n">usage</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="p">}</span>
        
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">bindings</span><span class="p">::</span><span class="nf">dma_resv_unlock</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">)</span> <span class="p">};</span>

        <span class="n">ret</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With that step, I could simply write the IOCTLs based on the new <code class="language-plaintext highlighter-rouge">DmaResv</code>
abstraction and Lina’s fence abstractions.</p>

<p>To test the IOCTLs, I used some already available IGT tests: <code class="language-plaintext highlighter-rouge">dmabuf_sync_file</code>
and <code class="language-plaintext highlighter-rouge">vgem_basic</code>. Those tests use VGEM as it base, so if the tests pass, it
means that the IOCTLs are working properly. And, after some debugging and rework
in the IOCTLs, I managed to get most of the tests to pass!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[root@fedora igt-gpu-tools]# ./build/tests/dmabuf_sync_file
IGT-Version: 1.27-gaa16e812 (x86_64) (Linux: 6.2.0-rc3-asahi-02441-g6c8eda039cfb-dirty x86_64)
Starting subtest: export-basic
Subtest export-basic: SUCCESS (0.000s)
Starting subtest: export-before-signal
Subtest export-before-signal: SUCCESS (0.000s)
Starting subtest: export-multiwait
Subtest export-multiwait: SUCCESS (0.000s)
Starting subtest: export-wait-after-attach
Subtest export-wait-after-attach: SUCCESS (0.000s)
</code></pre></div></div>

<p>You can check out the current progress of this project on this
<a href="https://github.com/mairacanal/linux/pull/11" target="_blank" rel="noopener noreferrer" class="external">pull request</a>.</p>

<h1 id="next-steps">Next Steps</h1>
<hr>
<p>Although most of the IGT tests are now passing, two tests aren’t working yet:
<code class="language-plaintext highlighter-rouge">vgem_slow</code>, as I haven’t introduced the timeout yet, and <code class="language-plaintext highlighter-rouge">vgem_basic@unload</code>,
as I still need to debug why the <code class="language-plaintext highlighter-rouge">Drop</code> trait from <code class="language-plaintext highlighter-rouge">drm::drv::Registration</code> is
not being called.</p>

<p>After bypassing those two problems, I still need to rework some of my code, as,
for example, I’m using a dummy IOCTL as IOCTL number 0x00, as the current macro
<code class="language-plaintext highlighter-rouge">kernel::declare_drm_ioctl</code> doesn’t support any drivers for which the IOCTL doesn’t
start in 0x00.</p>

<p>So, there is a lot of work yet to be done!</p>


  </article>
</main>

<footer>
  <address>
  <p>
      E-mail:
      <a href="mailto:mairacanal@riseup.net">mairacanal@riseup.net</a>
    <br>
    <span class="pgp">PGP:
      <a href="/pgp.asc">
        <span>F8E4 5D7D 0116 7707 29A6 77D1 </span> 3FF3 0E8A 7688 FAAA
      </a>
    </span>
  </p>

  <p>
    Social:
    <a href="https://github.com/mairacanal" class="external github" target="_blank" rel="noopener noreferrer">GitHub</a>;
    <a href="https://gitlab.freedesktop.org/mairacanal" class="external gitlab" target="_blank" rel="noopener noreferrer">GitLab</a>;
    <a href="https://linkedin.com/in/mairacanal" class="external linkedin" target="_blank" rel="noopener noreferrer">LinkedIn</a>;
    <a rel="me noopener noreferrer" href="https://fosstodon.org/@mairacanal" class="external mastodon" target="_blank">Mastodon</a>
  </p>

  <p class="copyleft">Copyleft(C) <a href="https://m7.rs/" target="_blank" rel="noopener noreferrer" class="external">Gabriel Fontes</a> (<a href="https://github.com/Misterio77/website" target="_blank" rel="noopener noreferrer" class="external">Source Code</a>)</p>
</address>

<p class="print-site-link"><small>Also available at <a href="https://mairacanal.github.io/rust-for-vgem/">my website</a>.</small></p>

</footer>

  </body>
</html>
