<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Maíra Canal | Rotating Planes on VKMS</title>
    <meta name="description" content="Blogging about graphics development whenever I can"
    />
    

    <link rel="canonical" href="https://mairacanal.github.io/rotating-planes-vkms/" />
    <!-- Common head elements I use in this website and cgit -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="icon" href="data:,">

<link rel="stylesheet" href="/assets/style.css" />
<link rel="stylesheet" href="https://m7.rs/colors/catppuccin-frappe.css" />
<link rel="stylesheet" href="https://m7.rs/colors/catppuccin-frappe.css" media="(prefers-color-scheme: dark)" />
<link rel="stylesheet" href="https://m7.rs/colors/.css" media="print" />
<link rel="stylesheet" id="theme-css" />

<script src="/assets/main.js"></script>

  </head>
  <body>
    <header>
  <div class="title">{ <a href="/">Maíra Canal</a> }</div>
<nav>
    <ul>
      
      <li>
        <a class="colorscheme" aria-label="Change colorscheme" href="/colorscheme/">
          
        </a>
      </li>
      
      <li>
        <a href="/about-me/">
          
            about
          
        </a>
      </li>
      
      <li>
        <a href="/">
          
            blog
          
        </a>
      </li>
      
      <li>
        <a href="/life/">
          
            life
          
        </a>
      </li>
      
      <li>
        <a href="/cv/">
          
            cv
          
        </a>
      </li>
      
    </ul>
</nav>

</header>

<main>
  <article>
    <header>
      <h1>Rotating Planes on VKMS</h1>
      
      
        <p>
          Date: <time datetime="2023-05-08T00:00:00+00:00">8th May 2023</time>
        </p>
      
      
        <p>
          Tags:
          
            <a href="/notes#igalia">#igalia</a>
          
            <a href="/notes#kernel">#kernel</a>
          
            <a href="/notes#graphics">#graphics</a>
          
        </p>
      
    </header>

    <p>In my last blog post, I described a bit of my previous work on the <code class="language-plaintext highlighter-rouge">rustgem</code> project, and after that, as I had finished the VGEM features, I sent a <a href="https://lore.kernel.org/dri-devel/20230317121213.93991-1-mcanal@igalia.com/T/" class="external">RFC</a> to the mailing list.
Although I still need to work on some <code class="language-plaintext highlighter-rouge">rustgem</code> feedback, I started to explore more of the KMS (Kernel Mode Setting) and its properties.</p>

<p>I talked to my mentor <a href="https://melissawen.github.io/" class="external">Melissa Wen</a>, one of the VKMS maintainers, and she proposed implementing plane rotation capabilities to VKMS.
The VKMS (Virtual Kernel Mode Setting) is a software-only KMS driver that is quite useful for testing and running X (or similar compositors) on headless machines.
It sounded like a great idea, as I would like to explore a bit more of the KMS side of things.</p>

<h1 id="what-is-plane-rotation">What is Plane Rotation?</h1>
<hr>
<p>In order to have an image on a display, we need to go through the whole Kernel Mode Setting (KMS) Display Pipeline.
The pipeline has a couple of different objects, such as framebuffers, planes, and CRTCs, and the relationship between them can be quite complicated.
If you are interested in the KMS Display Pipeline, I recommend reading the great <a href="https://docs.kernel.org/gpu/drm-kms.html" class="external">KMS documentation</a>.
But here we are focused in only one of those abstractions, the plane.</p>

<p>In the context of graphics processing, a plane refers to an image source that can be superimposed or blended on top of a CRTC during the scanout process.
The plane itself specifies the cropping and scaling of that image, and where it is placed on the visible area of the CRTC.
Moreover, planes may possess additional attributes that dictate pixel positioning and blending, such as rotation or Z-positioning.</p>

<p>Rotation is an optional KMS property of the DRM plane object, which we use to specify the rotation amount in degrees in counter-clockwise direction.
The rotation is applied to the image sampled from the source rectangle, before scaling it to fit in the destination rectangle.
So, basically, the rotation property adds a rotation and a reflection step between the source and destination rectangles.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		|*********|$$$$$$$$$|              |$$$$$$$$$|@@@@@@@@@|
		|*********|$$$$$$$$$|  ---------&gt;  |$$$$$$$$$|@@@@@@@@@|
		|#########|@@@@@@@@@|     90º      |*********|#########|
		|#########|@@@@@@@@@|              |*********|#########|
</code></pre></div></div>

<p>The possible rotation values are <code class="language-plaintext highlighter-rouge">rotate-0</code>, <code class="language-plaintext highlighter-rouge">rotate-90</code>, <code class="language-plaintext highlighter-rouge">rotate-180</code>, <code class="language-plaintext highlighter-rouge">rotate-270</code>, <code class="language-plaintext highlighter-rouge">reflect-x</code> and <code class="language-plaintext highlighter-rouge">reflect-y</code>.</p>

<p>Now that we understand what plane rotation is, we can think about how to implement the rotation property on VKMS.</p>

<h1 id="rotation-on-vkms">Rotation on VKMS</h1>
<hr>
<p>VKMS has some really special driver attributes, as all its composition happens by software operations.
The rotation is usually an operation that is performed on the user-space, but the hardware can also perform it.
In order for the hardware to perform it, the driver will set some registers, change some configurations, and indicate to the hardware that the plane should be rotated.
This doesn’t happen on VKMS, as the composition is essentially a software loop.
So, we need to modify this loop to perform the rotation.</p>

<p>First, we need a brief notion of how the composition happens in VKMS.
The composition in VKMS happens line-by-line.
Each line is represented by a staging buffer, which contains the composition for one plane, and an output buffer, which contains the composition of all planes in z-pos order.
For each line, we query an array by the first pixel of the line and go through the whole source array linearly, performing the proper pixel conversion.
The composition of the line can be summarized by:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vkms_compose_row</span><span class="p">(</span><span class="k">struct</span> <span class="n">line_buffer</span> <span class="o">*</span><span class="n">stage_buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vkms_plane_state</span> <span class="o">*</span><span class="n">plane</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pixel_argb_u16</span> <span class="o">*</span><span class="n">out_pixels</span> <span class="o">=</span> <span class="n">stage_buffer</span><span class="o">-&gt;</span><span class="n">pixels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vkms_frame_info</span> <span class="o">*</span><span class="n">frame_info</span> <span class="o">=</span> <span class="n">plane</span><span class="o">-&gt;</span><span class="n">frame_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">src_pixels</span> <span class="o">=</span> <span class="n">get_packed_src_addr</span><span class="p">(</span><span class="n">frame_info</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">drm_rect_width</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame_info</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">),</span> <span class="n">stage_buffer</span><span class="o">-&gt;</span><span class="n">n_pixels</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">,</span> <span class="n">src_pixels</span> <span class="o">+=</span> <span class="n">frame_info</span><span class="o">-&gt;</span><span class="n">cpp</span><span class="p">)</span>
		<span class="n">plane</span><span class="o">-&gt;</span><span class="n">pixel_read</span><span class="p">(</span><span class="n">src_pixels</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_pixels</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we can see that we have the line, represented by the stage buffer and the y coordinate, and the source pixels.
We read each source pixel in a linear manner, through the for-loop, and we place it on the stage buffer in the appropriate format.</p>

<p>With that in mind, we can think that rotating a plane is a matter of changing how we read and interpret the lines.
Let’s think about the <code class="language-plaintext highlighter-rouge">reflect-x</code> operation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		|*********|$$$$$$$$$|                |$$$$$$$$$|*********|
		|*********|$$$$$$$$$|  -----------&gt;  |$$$$$$$$$|*********|
		|#########|@@@@@@@@@|   reflect-x    |@@@@@@@@@|#########|
		|#########|@@@@@@@@@|                |@@@@@@@@@|#########|
</code></pre></div></div>

<p>Thinking that the VKMS composition happens line-by-line, we can describe the operation as a read in reverse order.
So, instead of start reading the pixels from left to right, we need to start reading the pixels from right to left.
We can implement this by getting the limit of the line and subtracting the current <code class="language-plaintext highlighter-rouge">x</code> position:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">get_x_position</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vkms_frame_info</span> <span class="o">*</span><span class="n">frame_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame_info</span><span class="o">-&gt;</span><span class="n">rotation</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_REFLECT_X</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For the <code class="language-plaintext highlighter-rouge">reflect-y</code> operation, we need to start reading the plane from the last line, instead of reading it from the first line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		|*********|$$$$$$$$$|                |#########|@@@@@@@@@|
		|*********|$$$$$$$$$|  -----------&gt;  |#########|@@@@@@@@@|
		|#########|@@@@@@@@@|   reflect-y    |*********|$$$$$$$$$|
		|#########|@@@@@@@@@|                |*********|$$$$$$$$$|
</code></pre></div></div>

<p>This can be performed by changing the <code class="language-plaintext highlighter-rouge">y</code> on the external composition loop.
Similarly from the <code class="language-plaintext highlighter-rouge">reflect-x</code> case, we can get the <code class="language-plaintext highlighter-rouge">y</code> limit and subtract the current <code class="language-plaintext highlighter-rouge">y</code> position.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">get_y_pos</span><span class="p">(</span><span class="k">struct</span> <span class="n">vkms_frame_info</span> <span class="o">*</span><span class="n">frame_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame_info</span><span class="o">-&gt;</span><span class="n">rotation</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_REFLECT_Y</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">drm_rect_height</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame_info</span><span class="o">-&gt;</span><span class="n">rotated</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So, to implement the rotation in VKMS, we need to change how we interpret the boundaries of the plane and read accordingly.</p>

<p>This might seem odd because we could just rotate the <code class="language-plaintext highlighter-rouge">src</code> rectangle by using <code class="language-plaintext highlighter-rouge">drm_rect_rotate</code>, but this wouldn’t work as the composition in VKMS is performed line-by-line and the pixels are accessed linearly.
However, <code class="language-plaintext highlighter-rouge">drm_rect_rotate</code> is of great help for us on the <code class="language-plaintext highlighter-rouge">rotate-90</code> and <code class="language-plaintext highlighter-rouge">rotate-270</code> cases.
Those cases demand scaling and <code class="language-plaintext highlighter-rouge">drm_rect_rotate</code> helps us tremendously with it.
Basically, what it does is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		                                              |$$|@@|
		                                              |$$|@@|
		|*********|$$$$$$$$$|                         |$$|@@|
		|*********|$$$$$$$$$|  --------------------&gt;  |$$|@@|
		|#########|@@@@@@@@@|   drm_rect_rotate(90)   |**|##|
		|#########|@@@@@@@@@|                         |**|##|
		                                              |**|##|
		                                              |**|##|
</code></pre></div></div>

<p>After the <code class="language-plaintext highlighter-rouge">drm_rect_rotate</code> operation, we need to read the columns as lines and the lines as columns.
See that even for a case like <code class="language-plaintext highlighter-rouge">rotate-90</code>, it is just a matter of changing the point of view and reading the lines differently.</p>

<hr>
<p>The complete implementation of all rotation modes is available <a href="https://patchwork.freedesktop.org/series/116189/" class="external">here</a>.
Together with the rotation feature, I sent a patch to reduce the code repetition in the code by isolating the pixel conversion functionality.
This patch was already merged, but the rest of the series is still pending a Reviewed-by.</p>

<p>Rotating planes on VKMS was a fun challenge of my <a href="https://www.igalia.com/coding-experience/" class="external">Igalia Coding Experience</a> and I hope to keep working on VKMS to bring more and more features.</p>


  </article>
</main>

<footer>
  <address>
  <p>
      E-mail:
      <a href="mailto:mairacanal@riseup.net">mairacanal@riseup.net</a>
    <br>
    <span class="pgp">PGP:
      <a href="/pgp.asc">
        <span>D902 5017 00AF C8B3 A4F6 7C20</span> B02E E8FD 7678 1ED5
      </a>
    </span>
  </p>

  <p>
    Social:
    <a href="https://github.com/mairacanal" class="external">GitHub</a>;
    <a href="https://gitlab.freedesktop.org/mairacanal" class="external">GitLab</a>;
    <a href="https://linkedin.com/in/mairacanal" class="external">LinkedIn</a>;
    <a href="https://matrix.to/#/@mairacanal:matrix.org" class="external">Matrix</a>;
  </p>

  <p class="copyleft">Copyleft <a href="https://m7.rs/" class="external">Gabriel Fontes</a> (<a href="https://github.com/Misterio77/website" class="external">Source Code</a>)</p>
</address>

<p class="print-site-link"><small>Also available at <a href="https://mairacanal.github.io/rotating-planes-vkms/" class="external">my website</a>.</small></p>

</footer>

  </body>
</html>
